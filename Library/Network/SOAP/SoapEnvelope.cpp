// Jon Bellamy 09/10/2009



#if USE_PCH
#include "stdafx.h"
#endif

#include <vector>

#include "SoapEnvelope.h"
#include "Soap.h"


namespace net 
{



//////////////////////////////////////////////////////////////////////////
// cSoapRequest



// The namespace identifiers are standard and the SOAP specification requires that these namespaces either be defined correctly or not at all (ie. a SOAP message with missing namespace 
// definitions is correct and processable but one with incorrect, ie. non-standard, definitions is incorrect and discardable).
cSoapRequest::cSoapRequest()
: mXmlDoc()
, mXmlDeclarationNode("1.0", "utf-8", "")				// <?xml version="1.0" encoding="utf-8"?>
, mSoapEnvelopeNode(SOAP_ENVELOPE_NODE)
, mSoapBodyNode(SOAP_BODY_NODE)
, mSoapServiceName(UNINITALIZED_SOAP_PARAM)
{
	// Set namespace schemas, these actually seem to be referenced and used by the services we are calling. I've seen malformed responses if i pass corrupt strings here!
	// These seems to act almost like #includes. For instance if you do not set the xsi schema then you cannot use types in the parameters you are sending (type='string' etc), if you try
	// you just get server errors.
	mSoapEnvelopeNode.SetAttribute("xmlns:SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/");
	mSoapEnvelopeNode.SetAttribute("xmlns:SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/");
	mSoapEnvelopeNode.SetAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
	mSoapEnvelopeNode.SetAttribute("xmlns:xsd", "http://www.w3.org/2001/XMLSchema");


	// build the doc, use link functions so that we can alter the values later, insert functions takes a copy
	mXmlDoc.LinkEndChild(&mXmlDeclarationNode);
	mSoapBodyNode.LinkEndChild(&mSoapServiceName);
	mSoapEnvelopeNode.LinkEndChild(&mSoapBodyNode);
	mXmlDoc.LinkEndChild(&mSoapEnvelopeNode);
}// END cSoapRequest



std::string cSoapRequest::AsString() const
{
	// print to a string
	TiXmlPrinter printer;
	mXmlDoc.Accept(&printer);
	return printer.CStr();
}// END AsString



void cSoapRequest::SetService(std::string service, std::string serviceNamespace)
{
	// Note that the method tag is typically namespaced by the service name, eg urn:MySoapServices to ensure uniqueness

	// using namespace m to section off this stuff, probably don't need to but most examples seem to do this
	//std::string qualifiedServiceName = "m:" + service;
	//mSoapServiceName.SetValue(qualifiedServiceName.c_str());
	mSoapServiceName.SetValue(service.c_str());

	// This is required, service will fail if its not present, i think this defines our 'm' namespace (above) and needs setting up as such
	// TODO : http://tempuri.org/ is for development only
	//mSoapServiceName.SetAttribute("xmlns:m", "http://tempuri.org/");
	mSoapServiceName.SetAttribute("xmlns", serviceNamespace.c_str());	
	
}// END SetService



void cSoapRequest::AddParam(const std::string& paramName, int val)
{
	TiXmlElement* pParentNode = CreateParamTags(paramName);

	char str[32];
	sprintf(str, "%d", val);
	TiXmlElement xmlParam(GetFinalNodeNameForParam(paramName).c_str());
	TiXmlText    xmlParamVal(str);
	xmlParam.InsertEndChild(xmlParamVal);
	xmlParam.SetAttribute(XSI_TYPE, SUPPORTED_XSD_TYPES[cSoapType::SOAP_TYPE_INTEGER]);
	pParentNode->InsertEndChild(xmlParam);
}// END AddParam



void cSoapRequest::AddParam(const std::string& paramName, float val)
{
	TiXmlElement* pParentNode = CreateParamTags(paramName);

	char str[32];
	sprintf(str, "%f", val);
	TiXmlElement xmlParam(GetFinalNodeNameForParam(paramName).c_str());
	TiXmlText    xmlParamVal(str);
	xmlParam.InsertEndChild(xmlParamVal);
	xmlParam.SetAttribute(XSI_TYPE, SUPPORTED_XSD_TYPES[cSoapType::SOAP_TYPE_FLOAT]);
	pParentNode->InsertEndChild(xmlParam);
}// END AddParam



// Parameter tag names can be anything at all and are typically autogenerated and have no namespace, however i have seen services that fail if the params are not 
// named correctly. This may once again be differences between SOAP 1.1 & 1.2, really need to check this out.
void cSoapRequest::AddParam(const std::string& paramName, const std::string& val)
{
	TiXmlElement* pParentNode = CreateParamTags(paramName);

	TiXmlElement xmlParam(GetFinalNodeNameForParam(paramName).c_str());
	TiXmlText    xmlParamVal(val.c_str());
	xmlParam.InsertEndChild(xmlParamVal);
	xmlParam.SetAttribute(XSI_TYPE, SUPPORTED_XSD_TYPES[cSoapType::SOAP_TYPE_STRING]);
	pParentNode->InsertEndChild(xmlParam);
}// END AddParam



u32 cSoapRequest::NumberOfNamespacesInParam(const std::string& param)
{
	if(param.size() == 0)
	{
		assert(0);
		return 0;
	}

	std::string::size_type ret=0;
	u32 count=1;
	while(ret != std::string::npos)
	{
		ret = param.find_first_of(".", ret);
		
		if(ret != std::string::npos)
		{
			ret++;
			count++;
		}
	}
	return count;
}// END NumberOfNamespacesInParam



// if we pass in GetTile.id.x, GetTile is the service name, id is a namespace type block and x is the param:
/*
<GetTile xmlns="http://terraserver-usa.com/terraserver/">
	<id>
		<Theme>Photo or Topo or Relief</Theme>
		<Scale>Scale1mm or Scale2mm or Scale4mm or Scale8mm or Scale16mm or Scale32mm or Scale63mm or Scale125mm or Scale250mm or Scale500mm or Scale1m or Scale2m or Scale4m or Scale8m or Scale16m or Scale32m or Scale64m or Scale128m or Scale256m or Scale512m or Scale1km or Scale2km or Scale4km or Scale8km or Scale16km</Scale>
		<Scene>int</Scene>
		<X>int</X>
		<Y>int</Y>
	</id>
</GetTile>
*/
std::string cSoapRequest::GetNamespaceInParam(const std::string& param, u32 namespaceNumber)
{
	u32 nsCount = NumberOfNamespacesInParam(param);
	if(namespaceNumber > (nsCount-1))
	{
		// zero based
		assert(0);
		return "";
	}

	// store all the indices of the '.' and the implicit start
	std::vector<std::string::size_type> nsIndices;
	nsIndices.push_back(-1);
	std::string::size_type ret=0;
	while(ret != std::string::npos)
	{
		ret = param.find_first_of(".", ret);
		if(ret != std::string::npos)
		{
			nsIndices.push_back(ret);
			ret++;	
		}
	}

	size_t stringSize;
	if(namespaceNumber < nsCount-1)
	{
		stringSize = nsIndices[namespaceNumber+1] - nsIndices[namespaceNumber] - 1;
	}
	else
	{
		stringSize = param.size() - nsIndices[namespaceNumber];
	}

	return param.substr(nsIndices[namespaceNumber]+1, stringSize);
}// END GetNamespaceInParam



// returns the parent tag to add the param to
TiXmlElement* cSoapRequest::CreateParamTags(const std::string& qualifiedParamName)
{
	u32 nsCount = NumberOfNamespacesInParam(qualifiedParamName);
	
	if(nsCount > 1)
	{
		assert(GetNamespaceInParam(qualifiedParamName, 0) == mSoapServiceName.Value());

		// ensure the tags exist, but not the final tag as that will be the actual param value
		for(u32 i=1; i < nsCount-1; i++)
		{
			std::string tagName = GetNamespaceInParam(qualifiedParamName, i);

			bool bFound=false;
			TiXmlElement* pNode = mSoapServiceName.FirstChildElement();
			while(pNode)
			{
				if(pNode->Value() == tagName)
				{
					bFound = true;
					break;
				}

				pNode = mSoapServiceName.NextSiblingElement();
			}

			// not found, create it
			if(!bFound)
			{
				TiXmlElement newNode(tagName.c_str());
				mSoapServiceName.InsertEndChild(newNode);
			}		
		}

		// now lookup the node we want to add it to. -2 is because we are zero based so -1 and then the final ns is the tag for the param so -1 again
		std::string parentNodeToAddTo = GetNamespaceInParam(qualifiedParamName, nsCount-2);
		bool bFound=false;
		TiXmlElement* pNode = mSoapServiceName.FirstChildElement();
		while(pNode)
		{
			if(pNode->Value() == parentNodeToAddTo)
			{
				return pNode;
			}

			mSoapServiceName.NextSiblingElement();
		}

		// node not found even though we should have created them all above!
		assert(0);
		return NULL;
	}
	else
	{
		return &mSoapServiceName;
	}
}// END CreateParamTags


std::string cSoapRequest::GetFinalNodeNameForParam(const std::string& param)
{
	return GetNamespaceInParam(param, NumberOfNamespacesInParam(param)-1);
}// END GetFinalNodeNameForParam



//////////////////////////////////////////////////////////////////////////
// cSoapResponse



cSoapResponse::cSoapResponse(SoapResult r) 
: mResult(r) 
{
}// END cSoapResponse



cSoapResponse::cSoapResponse()
: mResult(SOAP_UNKNOWN_ERROR)
{
}// END cSoapResponse



// I fully expect invalid parse errors here when this is pointed at new services as i am learning as i go here. They shouldn't be a big deal to fixup.
void cSoapResponse::Parse(const char* responseXml) throw(...)
{
	std::string fullNodeNodeText;
	std::string nodeName;
	const char* szAttr;

	xmlDoc.Parse(responseXml);
	if (xmlDoc.Error())
	{
		goto fail;
	}
	xmlDoc.Print();

#if 1
	xmlDoc.SaveFile("c:\\test.xml");
#endif

	// <SOAP-ENV:Envelope ...>
	pEnvelopeElement = xmlDoc.RootElement();
	if(!pEnvelopeElement)
	{
		goto fail;
	}
	// namespace (which can be anything) followed by Envelope
	fullNodeNodeText = pEnvelopeElement->Value();
	nodeName = TrimNamespace(fullNodeNodeText);
	if(nodeName != ENVELOPE_ID)
	{
		goto fail;
	}



	// <SOAP-ENV:Body>
	pBodyElement = pEnvelopeElement->FirstChildElement();
	if(!pBodyElement)
	{
		goto fail;
	}
	fullNodeNodeText = pBodyElement->Value();
	nodeName = TrimNamespace(fullNodeNodeText);
	if(nodeName != BODY_ID)
	{
		goto fail;
	}


	// <mns:Method1Response ... >
	pResponseElement = pBodyElement->FirstChildElement();
	if(!pResponseElement)
	{

		// ***********************************************************
		// TODO : check for soap:fault here!!!
		// ***********************************************************

		goto fail;
	}
	fullNodeNodeText = pResponseElement->Value();
	nodeName = TrimNamespace(fullNodeNodeText);
	if(nodeName.find(RESPONSE_ID) == std::string::npos)
	{
		goto fail;
	}


	
	// In the response message there is only ever one parameter tag (representing the return value of the method) and it is typically named <return>
	//  <bstrReturn xsi:type="xsd:string">Hello World</bstrReturn>
	pReturnElement = pResponseElement->FirstChildElement();
	if(!pReturnElement)
	{
		goto fail;
	}
	
	// get the return type, if there isn't one, default to string
	szAttr = pReturnElement->Attribute(XSI_TYPE);
	if(szAttr)
	{
		returnSoapType = szAttr;
	}
	else
	{
		returnSoapType = SUPPORTED_XSD_TYPES[cSoapType::SOAP_TYPE_STRING];
	}
	if(pReturnElement->FirstChild() == NULL)
	{	
		returnSoapValue="";
	}
	else
	{
		returnSoapValue = pReturnElement->FirstChild()->Value();	
	}
	mReturnValue.Set(returnSoapType, returnSoapValue);



	mResult = SOAP_RESPONSE_OK;
	return;

fail:
	mResult = SOAP_PARSE_RESPONSE_FAIL;
	throw(SOAP_PARSE_RESPONSE_FAIL);
}// END Parse



std::string cSoapResponse::TrimNamespace(const std::string& fullNodeNodeText)
{
	std::string::size_type ret = fullNodeNodeText.find_first_of(":", 0);
	if(ret == std::string::npos)
	{
		return fullNodeNodeText;
	}
	ret++;	// pass the ':'
	return fullNodeNodeText.substr(ret, fullNodeNodeText.size() - ret);
}// END TrimNamespace



} // namespace net