// Jon Bellamy 19/11/2009


#include "KrpcMsg.h"


#include <assert.h>

#include "Network/BitTorrent/BitTorrentManager.h"
#include "Network/BitTorrent/dht/Dht.h"
#include "General/Endianness.h"
#include "File/file.h"


#define DEBUG_OUR_RESPONSE_MESSAGES 0

#define ADD_V_KEY 1


// KRPC dictionary keys
#define KRPC_KEY_TRANSACTION_ID "t"
#define KRPC_KEY_MESSAGE_TYPE "y"
#define KRPC_KEY_METHOD_NAME "q"
#define KRPC_KEY_METHOD_ARGUMENTS "a"
#define KRPC_KEY_ERROR "e"
#define KRPC_KEY_RESPONSE "r"

// KRPC message types (these are passed as the value in the cKrpcMsg constructor entry)
#define KRPC_MESSAGE_TYPE_VALUE_QUERY "q"
#define KRPC_MESSAGE_TYPE_VALUE_RESPONSE "r"
#define KRPC_MESSAGE_TYPE_VALUE_ERROR "e"

// KRPC method names
#define KRPC_PING_METHOD_NAME "ping"
#define KRPC_FIND_NODE_METHOD_NAME "find_node"
#define KRPC_GET_PEERS_METHOD_NAME "get_peers"
#define KRPC_ANNOUNCE_PEER_METHOD_NAME "announce_peer"


// error msg's
#define GENERIC_ERROR_CODE 201
#define GENERIC_ERROR_TEXT "Generic Error"
#define SERVER_ERROR_CODE 202
#define SERVER_ERROR_TEXT "Server Error"
#define PROTOCOL_ERROR_CODE 203
#define PROTOCOL_ERROR_TEXT "Protocol Error, such as a malformed packet, invalid arguments, or bad token"
#define UNKNOWN_ERROR_CODE 204
#define UNKNOWN_ERROR_TEXT "Method Unknown"


using namespace net;


// lets not start from zero
static u16 mNextTransactionId=0xABCD;



// A KRPC message is a single dictionary with two keys common to every message and additional keys depending on the type of message. Every message has a key "t" with a string value 
// representing a transaction ID. This transaction ID is generated by the querying node and is echoed in the response, so responses may be correlated with multiple queries to the same node. 
// The transaction ID should be encoded as a short string of binary numbers, typically 2 characters are enough as they cover 2^16 outstanding queries. The other key contained in every KRPC 
// message is "y" with a single character value describing the type of message. The value of the "y" key is one of "q" for query, "r" for response, or "e" for error.
cKrpcMsg::cKrpcMsg(const char* messageType, u16 responseTransactionId)
: mpTask(NULL)
, mSendTime(0)
{
	assert(messageType == KRPC_MESSAGE_TYPE_VALUE_QUERY || messageType == KRPC_MESSAGE_TYPE_VALUE_RESPONSE || messageType == KRPC_MESSAGE_TYPE_VALUE_ERROR);
	u16 transactionId;

	if(messageType == KRPC_MESSAGE_TYPE_VALUE_QUERY)
	{
		transactionId = mNextTransactionId++;
	}
	else
	{
		transactionId = responseTransactionId;
	}


	// every K-RPC message has a transaction id and a message type
	
	// transaction id (one dict kv)
	cBencodedString transactionKey(KRPC_KEY_TRANSACTION_ID);
	cBencodedString transactionValue(reinterpret_cast<const u8*>(&transactionId), 2);
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&transactionKey, &transactionValue));

	// message type (one dict kv)
	cBencodedString messageTypeKey(KRPC_KEY_MESSAGE_TYPE);
	cBencodedString messageTypeValue(messageType);
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&messageTypeKey, &messageTypeValue));

	// After noticing packets with this (then trawling the internet for some time) ...
	// In all KRPC messages, an optional "v" key is recommended, which contains a 4 byte value indicating the client and version. 
	// Existing "v" strings include "UTXX" and "ltXX", where XX is an unsigned short int representing the version or build number.
#if ADD_V_KEY
	cBencodedString clientKey("v");
	cBencodedString clientValue("MK01");		// version string
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&clientKey, &clientValue));
#endif
}// END cKrpcMsg


cKrpcMsg::~cKrpcMsg()
{
}


void cKrpcMsg::Load(const char* fn)
{
	cFile f(cFile::READ, fn, true);
	Parse(reinterpret_cast<const char*> (f.CachedFileData()), f.Size());
}// END Load



void cKrpcMsg::Save(const char* fn) const
{
	cFile f(cFile::WRITE, fn);
	f.Write(0, static_cast<u32> (mKrpcDict.RawData().size()), reinterpret_cast<const u8*> (mKrpcDict.RawData().c_str()));
	f.Close();
}// END Save




bool cKrpcMsg::Parse(const char* data, u32 dataSize)
{
	bool ret = mKrpcDict.Parse(data, dataSize);
//	assert(ret);
	return ret;
}// END Parse



u16 cKrpcMsg::TransactionId() const 
{ 
	u16 ret;
	const cBencodedString* transactionStr = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_TRANSACTION_ID));
	if(transactionStr)
	{
		const std::string& str = transactionStr->Get();
		memcpy(&ret, str.c_str(), sizeof(ret));
		return ret;
	}
	else
	{
		Printf("DHT: Warning no transaction Id\n.");
		return 0;
	}
}// END TransactionId



const cBencodedString* cKrpcMsg::MessageType() const
{
	const cBencodedString* messageTypeValue = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_MESSAGE_TYPE));	
	return messageTypeValue;
}// END MessageType



//////////////////////////////////////////////////////////////////////////
// Message Types



//////////////////////////////////////////////////////////////////////////
// Query

// Queries, or KRPC message dictionaries with a "y" value of "q", contain two additional keys; "q" and "a". Key "q" has a string value containing the method name of the query. 
// Key "a" has a dictionary value containing named arguments to the query.
cKrpcQuery::cKrpcQuery(const char* methodName)
: cKrpcMsg(KRPC_MESSAGE_TYPE_VALUE_QUERY, 0)
{
	// method name (one dict kv)
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_METHOD_NAME)), &(cBencodedString(methodName))));

	// can't add the argument list until its build (by calling AddArgument)
}// END cKrpcQuery



bool cKrpcQuery::Parse(const char* data, u32 dataSize)
{
	if(cKrpcMsg::Parse(data, dataSize))
	{	
		const cBencodedString* methodName = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_METHOD_NAME));
		const cBencodedDictionary* argumentsDict = dynamic_cast<const cBencodedDictionary*> (mKrpcDict.GetValue(KRPC_KEY_METHOD_ARGUMENTS));

		assert(methodName && argumentsDict);
		if(methodName && argumentsDict)
		{
			mArgumentsDict = *argumentsDict;
			return true;
		}
	}
	return false;
}// END Parse



const cBencodedString* cKrpcQuery::MethodName() const
{
	const cBencodedString* methodNameValue = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_METHOD_NAME));	
	return methodNameValue;
}// END MethodName



void cKrpcQuery::AddArgument(const char* argName, const cBencodedType& argValue)
{	
	mArgumentsDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(argName)), &argValue));
}// END AddArgument



const cBencodedType* cKrpcQuery::GetArgumentValue(const char* argName) const
{
	return mArgumentsDict.GetValue(argName);
}// END GetArgumentValue



//////////////////////////////////////////////////////////////////////////
// Response


// All queries have an "id" key and value containing the node ID of the querying node. All responses have an "id" key and value containing the node ID of the responding node.
// Responses, or KRPC message dictionaries with a "y" value of "r", contain one additional key "r". The value of "r" is a dictionary containing named return values. 
// Response messages are sent upon successful completion of a query.
cKrpcResponse::cKrpcResponse(u16 responseTransactionId)
: cKrpcMsg(KRPC_MESSAGE_TYPE_VALUE_RESPONSE, responseTransactionId)
{
	cBencodedString idKey("id");
	cBencodedString idValue(reinterpret_cast<const u8*>(BitTorrentManager().DhtTaskManager().Dht().LocalNodeId().AsString().c_str()), cDhtNodeId::NODE_ID_SIZE);
	AddElement(cBencodedDictionary::DictPair(&idKey, &idValue));
}// END cKrpcResponse



bool cKrpcResponse::Parse(const char* data, u32 dataSize)
{
	if(cKrpcMsg::Parse(data, dataSize))
	{
		const cBencodedString* msgType = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_MESSAGE_TYPE));
		const cBencodedDictionary* responseDict = dynamic_cast<const cBencodedDictionary*> (mKrpcDict.GetValue(KRPC_KEY_RESPONSE));

		if(msgType && msgType->Get() == KRPC_MESSAGE_TYPE_VALUE_RESPONSE && responseDict)
		{
			mResponseDict = *responseDict;
			return true;
		}
	}
	return false;
}// END Parse



// called before sending and after adding all the return values
void cKrpcResponse::Write()
{
	mResponseDict.Write(NULL);
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_RESPONSE)), &mResponseDict));
	mKrpcDict.Write(NULL);
}// END Write



const cBencodedType* cKrpcResponse::GetResponseValue(const char* argName) const
{
	return mResponseDict.GetValue(argName);
}// END GetResponseValue



//////////////////////////////////////////////////////////////////////////
// Error

cKrpcError::cKrpcError()
: mErrorCode(0)
{
}// END cKrpcError



// Errors, or KRPC message dictionaries with a "y" value of "e", contain one additional key "e". The value of "e" is a list. The first element is an integer representing the error code. 
// The second element is a string containing the error message. Errors are sent when a query cannot be fulfilled.
cKrpcError::cKrpcError(u16 responseTransactionId, u32 errCode, const char* errMsg)
: cKrpcMsg(KRPC_MESSAGE_TYPE_VALUE_ERROR, responseTransactionId)
, mErrorCode(errCode)
, mStrError(errMsg)
{
	assert(errCode >= 201 && errCode <= 204);
	mList.AddElement(&(cBencodedInt(errCode)));
	mList.AddElement(&(cBencodedString(errMsg)));
	mList.Write(NULL);
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_ERROR)), &mList));
	mKrpcDict.Write(NULL);	
}// END cKrpcError



bool cKrpcError::Parse(const char* data, u32 dataSize)
{
	if(cKrpcMsg::Parse(data, dataSize))
	{	
		const cBencodedString* msgType = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_MESSAGE_TYPE));
		const cBencodedList* errList = dynamic_cast<const cBencodedList*> (mKrpcDict.GetValue(KRPC_KEY_ERROR));

		// I've seen errList as a string here
		if(errList == NULL)
		{
			const cBencodedString* errString = dynamic_cast<const cBencodedString*> (mKrpcDict.GetValue(KRPC_KEY_ERROR));
			if(errString)
			{
				//Printf("DHT: Krpc error received: %s", errString->Get().c_str());
				mStrError = errString->Get();
				mErrorCode = 0;
				return true;
			}
		}
		else
		{		
			if(msgType && msgType->Get() == KRPC_MESSAGE_TYPE_VALUE_ERROR && errList && errList->Type() == cBencodedType::BEN_LIST)
			{
				mList = *errList;

				const cBencodedInt* code = dynamic_cast<const cBencodedInt*> (mList.GetElement(0));
				if(code)
				{					
					mErrorCode = static_cast<u32> (code->Get());					
				}

				const cBencodedString* msg = dynamic_cast<const cBencodedString*> (mList.GetElement(1));
				if(msg)
				{
					mStrError = msg->Get();
				}
	
				return true;
			}
		}
	}
	return false;
}// END Parse





//////////////////////////////////////////////////////////////////////////
// Query Types


// The most basic query is a ping. "q" = "ping" A ping query has a single argument, "id" the value is a 20-byte string containing the senders node ID in network byte order. 
// The appropriate response to a ping has a single key "id" containing the node ID of the responding node.
cKrpcPingQuery::cKrpcPingQuery(const u8* localNodeId)
: cKrpcQuery(KRPC_PING_METHOD_NAME)
{
	// build the arguments then add them
	cBencodedString idValue(localNodeId, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("id", idValue);
	
	// dictionaries and lists need to be written so their raw data exists
	mArgumentsDict.Write(NULL);

	// add the argument dictionary (one kv pair)
	cBencodedString keyStr(KRPC_KEY_METHOD_ARGUMENTS);
	cBencodedDictionary::DictPair dpair(&keyStr, &mArgumentsDict);
	mKrpcDict.AddElement(dpair);

	// message complete, write the raw bencoded data so it can be sent
	mKrpcDict.Write(NULL);
}// END cKrpcPingQuery



// Find node is used to find the contact information for a node given its ID. "q" == "find_node" A find_node query has two arguments, "id" containing the node ID of the 
// querying node, and "target" containing the ID of the node sought by the querier. When a node receives a find_node query, it should respond with a key "nodes" and 
// value of a string containing the compact node info for the target node or the K (8) closest good nodes in its own routing table.
cKrpcFindNodeQuery::cKrpcFindNodeQuery(const u8* localNodeId, const u8* requestedNodeId)
: cKrpcQuery(KRPC_FIND_NODE_METHOD_NAME)
{
	// id arg
	cBencodedString idValue(localNodeId, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("id", idValue);

	// target arg
	cBencodedString targetValue(requestedNodeId, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("target", targetValue);

	// all arguments added, write the dict
	mArgumentsDict.Write(NULL);

	// add the argument dictionary (one kv pair)
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_METHOD_ARGUMENTS)), &mArgumentsDict));

	// message complete, write the raw bencoded data so it can be sent
	mKrpcDict.Write(NULL);
}// END cKrpcFindNodeQuery



// Get peers associated with a torrent infohash. "q" = "get_peers" A get_peers query has two arguments, "id" containing the node ID of the querying node, and 
// "info_hash" containing the infohash of the torrent. If the queried node has peers for the infohash, they are returned in a key "values" as a list of strings. 
// Each string containing "compact" format peer information for a single peer. If the queried node has no peers for the infohash, a key "nodes" is returned 
// containing the K nodes in the queried nodes routing table closest to the infohash supplied in the query. In either case a "token" key is also included in 
// the return value. The token value is a required argument for a future announce_peer query. The token value should be a short binary string.
cKrpcGetPeersQuery::cKrpcGetPeersQuery(const u8* localNodeId, const u8* infoHash)
: cKrpcQuery(KRPC_GET_PEERS_METHOD_NAME)
{
	// id arg
	cBencodedString idValue(localNodeId, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("id", idValue);

	// info_hash arg
	cBencodedString infoHashValue(infoHash, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("info_hash", infoHashValue);

	// all arguments added, write the dict
	mArgumentsDict.Write(NULL);

	// add the argument dictionary (one kv pair)
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_METHOD_ARGUMENTS)), &mArgumentsDict));

	// message complete, write the raw bencoded data so it can be sent
	mKrpcDict.Write(NULL);
}// END cKrpcGetPeersQuery



// Announce that the peer, controlling the querying node, is downloading a torrent on a port. announce_peer has four arguments: "id" containing the node ID of the querying 
// node, "info_hash" containing the infohash of the torrent, "port" containing the port as an integer, and the "token" received in response to a previous get_peers query. 
// The queried node must verify that the token was previously sent to the same IP address as the querying node. Then the queried node should store the IP address of the querying node 
// and the supplied port number under the infohash in its store of peer contact information.
cKrpcAnnouncePeerQuery::cKrpcAnnouncePeerQuery(const u8* localNodeId, const u8* infoHash, u16 port, const std::string& token)
: cKrpcQuery(KRPC_ANNOUNCE_PEER_METHOD_NAME)
{
	// id arg
	cBencodedString idValue(localNodeId, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("id", idValue);

	// info_hash arg
	cBencodedString infoHashValue(infoHash, cDhtNodeId::NODE_ID_SIZE);
	cKrpcQuery::AddArgument("info_hash", infoHashValue);

	// port arg
	cBencodedInt portValue(port);
	cKrpcQuery::AddArgument("port", portValue);

	// token arg
	cBencodedString tokenValue(reinterpret_cast<const u8*> (token.c_str()), static_cast<u32> (token.size()));
	cKrpcQuery::AddArgument("token", tokenValue);

	// all arguments added, write the dict
	mArgumentsDict.Write(NULL);

	// add the argument dictionary (one kv pair)
	mKrpcDict.AddElement(cBencodedDictionary::DictPair(&(cBencodedString(KRPC_KEY_METHOD_ARGUMENTS)), &mArgumentsDict));

	// message complete, write the raw bencoded data so it can be sent
	mKrpcDict.Write(NULL);
}// END cKrpcAnnouncePeerQuery





void OnReceiveKrpcDatagram(const net::cSockAddr& from, const char* data, u32 dataSize)
{
	//Printf("DHT: OnReceiveKrpcDatagram from %s:%u\n", addr.Ip().AsString(), addr.Port());
	cKrpcMsg msg;
	bool ret = msg.Parse(data, dataSize);
	if(ret == false)
	{
		Printf("Dht: Bad Krpc datagram (unable to parse)\n");
		//assert(0);
		return;
	}

	const cBencodedString* msgType = msg.MessageType();
	if(!msgType)
	{
		assert(0);
		return;
	}

	if(msgType->Get() == KRPC_MESSAGE_TYPE_VALUE_QUERY)
	{
		cKrpcQuery query;
		query.Parse(data, dataSize);
		OnReceiveKrpcQuery(from, query);
	}
	else if (msgType->Get() == KRPC_MESSAGE_TYPE_VALUE_RESPONSE)
	{
		cKrpcResponse response;
		response.Parse(data, dataSize);
		OnReceiveKrpcResponse(from, response);
	}
	else if (msgType->Get() == KRPC_MESSAGE_TYPE_VALUE_ERROR)
	{
		cKrpcError error;
		error.Parse(data, dataSize);
		OnReceiveKrpcError(from, error);
	}
	else
	{
		// I have seen this fire with a masType of 'p'
		Printf("Dht: Warning unknown KRPC message type, ignoring\n");
	}
}// END OnReceiveKrpcDatagram





//////////////////////////////////////////////////////////////////////////
// incoming KRPC error


void OnReceiveKrpcError(const net::cSockAddr& from, const cKrpcError& msg)
{
	Printf("Dht: OnReceiveKrpcError %u : %s\n", msg.ErrorCode(), msg.ErrorMessage().c_str());

#if LOG_DHT_MESSAGES
	BitTorrentManager().DhtTaskManager().Dht().PacketLog().LogKrpcMessage(BitTorrentManager().DhtTaskManager().Dht().Time(), from, msg, PTYPE_RECEIVE);
#endif

	// lookup the message the error is referring to
	const cKrpcQuery* query = BitTorrentManager().DhtTaskManager().Dht().GetOutstandingMessage(msg.TransactionId());
	if(!query)
	{
		//Printf("DHT: Bad krpc error (old or timed-out data arriving?)\n");
		BitTorrentManager().DhtTaskManager().Dht().OnUnMatchedResponseReceived();
		return;
	}

	// TODO : should be or OnError
	query->GetTask()->OnTaskResponseTimeout(*query);
	
	BitTorrentManager().DhtTaskManager().Dht().OnQueryResponseReceived(*query);
}// END OnReceiveKrpcError





//////////////////////////////////////////////////////////////////////////
// incoming KRPC query


void OnReceiveKrpcQuery(const net::cSockAddr& from, const cKrpcQuery& query)
{
#if LOG_DHT_MESSAGES
	BitTorrentManager().DhtTaskManager().Dht().PacketLog().LogKrpcMessage(BitTorrentManager().DhtTaskManager().Dht().Time(), from, query, PTYPE_RECEIVE);
#endif

	const cBencodedString* methodName = query.MethodName();
	if(!methodName)
	{
		assert(0);
		return;
	}

	// All queries have an "id" key and value containing the node ID of the querying node.
	const cBencodedString* idStr = dynamic_cast<const cBencodedString*> (query.GetArgumentValue("id"));
	if(!idStr)
	{
		// id should be in the arguments section, double check its not in the root of the query dictionary
		assert(0);
		return;
	}
	cDhtNode theirId(from, idStr->Get());
	BitTorrentManager().DhtTaskManager().Dht().RoutingTable().PresentNode(theirId);

	if(methodName->Get() == KRPC_PING_METHOD_NAME)
	{
		OnReceiveKrpcPingMsg(from, query);
	}
	else if (methodName->Get() == KRPC_FIND_NODE_METHOD_NAME)
	{
		OnReceiveKrpcFindNodeMsg(from, query);
	}
	else if (methodName->Get() == KRPC_GET_PEERS_METHOD_NAME)
	{
		OnReceiveKrpcGetPeersMsg(from, query);
	}
	else if (methodName->Get() == KRPC_ANNOUNCE_PEER_METHOD_NAME)
	{
		OnReceiveKrpcAnnounceMsg(from, query);
	}
	else
	{
		assert(0);
	}
}// END OnReceiveKrpcQuery



// The appropriate response to a ping has a single key "id" containing the node ID of the responding node.
void OnReceiveKrpcPingMsg(const net::cSockAddr& from, const cKrpcQuery& msg)
{
	//Printf("DHT: OnReceiveKrpcPingMsg\n");

	// NB : adding the transaction id of the msg we just got to our response
	cKrpcResponse response(msg.TransactionId());
	
	// id is added by default in cKrpcResponse
	
	response.Write();

#if DEBUG_OUR_RESPONSE_MESSAGES
	response.Save("ping-response.ben");
#endif

	BitTorrentManager().DhtTaskManager().Dht().SendResponse(from, response);
}// END OnReceiveKrpcPingMsg




// When a node receives a find_node query, it should respond with a key "nodes" and value of a string containing the compact 
// node info for the target node or the K (8) closest good nodes in its own routing table.
void OnReceiveKrpcFindNodeMsg(const net::cSockAddr& from, const cKrpcQuery& msg)
{
	//Printf("DHT: OnReceiveKrpcFindNodeMsg\n");

	// NB : adding the transaction id of the msg we just got to our response
	cKrpcResponse response(msg.TransactionId());

	// do we have the requested node
	const cBencodedString* targetArg = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("target"));
	if(targetArg == NULL)
	{
		return;
	}

	bool responseSent = false;
	if(targetArg)
	{
		const std::string targetId = targetArg->Get();
		assert(targetId.size() == cDhtNodeId::NODE_ID_SIZE);
		if(targetId.size() == cDhtNodeId::NODE_ID_SIZE)
		{
			cDhtNodeId targetNodeId(targetId);

			DhtNodePtrVector closestNodes;
			BitTorrentManager().DhtTaskManager().Dht().RoutingTable().ClosestNodeToInfoHash(targetNodeId, cDht::NODE_COUNT_FOR_QUERY_AND_RETURN, &closestNodes);

			cBencodedDictionary::DictPair dPair;
			cBencodedString key("nodes");
			dPair.pKey = &key;

			const cDhtNode* pNode = BitTorrentManager().DhtTaskManager().Dht().RoutingTable().Node(targetNodeId);
			if(pNode)
			{
				// for now, if we have it then just send it solo
				// TODO : send it along with the 7 closest
				std::string compactInfo = pNode->ToCompactRepresentation();
				cBencodedString val(reinterpret_cast<const u8*> (compactInfo.c_str()), cDhtNodeId::NODE_ID_SIZE);
				dPair.pValue = &val;
				response.AddElement(dPair);
			}
			else
			{
				std::string peersStr;

				// send K closest nodes
				for(u32 i=0; i < closestNodes.size(); i++)
				{
					const cDhtNode* node = closestNodes[i];
					std::string compactInfo = node->ToCompactRepresentation();

					peersStr.insert(i*cDhtNode::COMPACT_NODE_SIZE, compactInfo.c_str(), cDhtNode::COMPACT_NODE_SIZE);
				}
				cBencodedString val(reinterpret_cast<const u8*> (peersStr.c_str()), static_cast<u32>(peersStr.size()));

				dPair.pValue = &val;
				response.AddElement(dPair);
			}

			response.Write();

#if DEBUG_OUR_RESPONSE_MESSAGES
			response.Save("FindNode-response.ben");
#endif

			BitTorrentManager().DhtTaskManager().Dht().SendResponse(from, response);
			responseSent = true;
		}
	}

	if(!responseSent)
	{
		assert(0);
		//cKrpcError error; ...
		//SendError();
	}
}// END OnReceiveKrpcFindNodeMsg



// If the queried node has peers for the infohash, they are returned in a key "values" as a list of strings. Each string containing "compact" format 
// peer information for a single peer. If the queried node has no peers for the infohash, a key "nodes" is returned containing the K nodes in the 
// queried nodes routing table closest to the infohash supplied in the query. In either case a "token" key is also included in the return value.
void OnReceiveKrpcGetPeersMsg(const net::cSockAddr& from, const cKrpcQuery& msg)
{
	//Printf("DHT: OnReceiveKrpcGetPeersMsg\n");

	const cBencodedString* pbStrResourceId = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("info_hash"));	
	if(!pbStrResourceId || pbStrResourceId->Get().size() != cDhtNodeId::NODE_ID_SIZE)
	{
		return;
	}

	const cBencodedString* pbStrNodeId = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("id"));	
	if(!pbStrNodeId)
	{
		return;
	}
	
	cDhtResourceId resourceId(pbStrResourceId->Get());
	cDhtNode fromNode(from, pbStrNodeId->Get());
	std::string ourToken = BitTorrentManager().DhtTaskManager().Dht().GenerateToken(fromNode, resourceId);
	
	// update our resource info database
	DhtResourceInfoManager().OnGetPeersReceived(fromNode, resourceId, ourToken);


	// NB : adding the transaction id of the msg we just got to our response
	cKrpcResponse response(msg.TransactionId());
	
	// add the token
	response.AddElement(cBencodedDictionary::DictPair(&cBencodedString("token"), &cBencodedString(reinterpret_cast<const u8*> (ourToken.c_str()), static_cast<u32> (ourToken.size()))));

	std::vector<cPeerWithResource> peerWithResource;
	DhtResourceInfoManager().AllPeersForResource(resourceId, &peerWithResource, true);


	// if we have peers for the resource, grab & return them
	if(peerWithResource.size() > 0)
	{
		cBencodedDictionary::DictPair dPair;
		cBencodedString key("values");
		dPair.pKey = &key;

		cBencodedList peerList;

		for(u32 i=0; i < peerWithResource.size(); i++)
		{
			cPeerWithResource& peerInfo = peerWithResource[i];
			cSockAddr addr(peerInfo.mNode.Address().Ip(), peerInfo.mAnnouncedPort);
			
			std::string compact;
			u32 ip = addr.Ip().AsU32();
			u16 port = addr.Port();
			endian_swap(ip);
			endian_swap(port);
			compact.insert(0, reinterpret_cast<const char*>(&ip), sizeof(u32));
			compact.insert(sizeof(u32), reinterpret_cast<const char*>(&port), sizeof(u16));

			cBencodedString bStr(reinterpret_cast<const u8*>(compact.c_str()), static_cast<u32>(compact.size()));
			peerList.AddElement(&bStr);
		}


		dPair.pValue = &peerList;
		response.AddElement(dPair);
	}
	else
	{

		// closest nodes
		cBencodedDictionary::DictPair dPair;
		cBencodedString key("nodes");
		dPair.pKey = &key;

		DhtNodePtrVector closestNodes;
		BitTorrentManager().DhtTaskManager().Dht().RoutingTable().ClosestNodeToInfoHash(resourceId, cDht::NODE_COUNT_FOR_QUERY_AND_RETURN, &closestNodes);

		std::string peersStr;

		// send K closest nodes
		for(u32 i=0; i < closestNodes.size(); i++)
		{
			const cDhtNode* node = closestNodes[i];
			std::string compactInfo = node->ToCompactRepresentation();

			peersStr.insert(i*cDhtNode::COMPACT_NODE_SIZE, compactInfo.c_str(), cDhtNode::COMPACT_NODE_SIZE);
		}
		cBencodedString val(reinterpret_cast<const u8*> (peersStr.c_str()), static_cast<u32>(peersStr.size()));

		dPair.pValue = &val;
		response.AddElement(dPair);
	}
	response.Write();

#if DEBUG_OUR_RESPONSE_MESSAGES
	response.Save("GetPeers-response.ben");
#endif

	BitTorrentManager().DhtTaskManager().Dht().SendResponse(from, response);
}// END OnReceiveKrpcGetPeersMsg



// Announce that the peer, controlling the querying node, is downloading a torrent on a port. announce_peer has four arguments: 
// "id" containing the node ID of the querying node, "info_hash" containing the infohash of the torrent, "port" containing the 
// port as an integer, and the "token" received in response to a previous get_peers query. The queried node must verify that the 
// token was previously sent to the same IP address as the querying node. Then the queried node should store the IP address of 
// the querying node and the supplied port number under the infohash in its store of peer contact information.
void OnReceiveKrpcAnnounceMsg(const net::cSockAddr& from, const cKrpcQuery& msg)
{
	//Printf("DHT: OnReceiveKrpcAnnounceMsg\n");

	// NB : no reply
	
	const cBencodedString* pbStrNodeId = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("id"));	
	if(!pbStrNodeId)
	{
		return;
	}
	cDhtNode fromNode(from, pbStrNodeId->Get());

	const cBencodedString* pbStrInfoHash = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("info_hash"));	
	if(!pbStrInfoHash)
	{
		return;
	}
	cDhtResourceId resourceId(pbStrInfoHash->Get());

	const cBencodedString* pbStrToken = dynamic_cast<const cBencodedString*> (msg.GetArgumentValue("token"));	
	if(!pbStrToken)
	{
		return;
	}

	const cBencodedInt* pbStrPort = dynamic_cast<const cBencodedInt*> (msg.GetArgumentValue("port"));	
	if(!pbStrPort)
	{
		return;
	}

	// get the peer contact info
	cPeerWithResource* pPeerInfo = DhtResourceInfoManager().GetPeerInfo(fromNode, resourceId);	
	if(!pPeerInfo)
	{
		Printf("Dht: Peer announced to us but peer info not found.\n");
		return;
	}

	if(pPeerInfo->mInternalToken != pbStrToken->Get())
	{
		//assert(0);
		Printf("DHT: Token mismatch on krpc announce recv\n");
		return;
	}

	// store the port
	pPeerInfo->mAnnouncedPort = static_cast<u16> (pbStrPort->Get());
	pPeerInfo->mbHasAnnouncedToUs = true;


	// TODO : reply ...
	//assert(0);
	Printf("DHT: TODO: OnReceiveKrpcAnnounceMsg NEED TO REPLY HERE");
}// END OnReceiveKrpcAnnounceMsg





//////////////////////////////////////////////////////////////////////////
// incoming KRPC responses


void OnReceiveKrpcResponse(const net::cSockAddr& from, const cKrpcResponse& response)
{
#if LOG_DHT_MESSAGES
	BitTorrentManager().DhtTaskManager().Dht().PacketLog().LogKrpcMessage(BitTorrentManager().DhtTaskManager().Dht().Time(), from, response, PTYPE_RECEIVE);
#endif

	// lookup the message the response is referring to
	const cKrpcQuery* query = BitTorrentManager().DhtTaskManager().Dht().GetOutstandingMessage(response.TransactionId());
	if(!query)
	{
		//Printf("bad krpc response. Transaction %u. (old or timed-out data arriving?)\n", response.TransactionId());
		BitTorrentManager().DhtTaskManager().Dht().OnUnMatchedResponseReceived();
		return;
	}

	// check that the message is from who we sent it to
	if(query->SentTo().Address() != from)
	{
		//assert(0);
		Printf("Dht: send / recv address mismatch\n");
		return;
	}

	const cBencodedString* methodName = query->MethodName();
	if(!methodName)
	{
		assert(0);
		return;
	}

	// All responses have an "id" key and value containing the node ID of the response node.
	const cBencodedString* idStr = dynamic_cast<const cBencodedString*> (response.GetResponseValue("id"));
	if(!idStr)
	{
		// id should be in the arguments section, double check its not in the root of the query dictionary
		return;
	}
	// no need for this, i think as we will have already presented this node before we sent off the query
	//cDhtNode theirId(from, idStr->Get());
	//BitTorrentManager().DhtTaskManager().Dht().RoutingTable().PresentNode(theirId);


	if(methodName->Get() == KRPC_PING_METHOD_NAME)
	{
		OnReceiveKrpcPingResponse(from, *query, response);
	}
	else if (methodName->Get() == KRPC_FIND_NODE_METHOD_NAME)
	{
		OnReceiveKrpcFindNodeResponse(from, *query, response);
	}
	else if (methodName->Get() == KRPC_GET_PEERS_METHOD_NAME)
	{
		OnReceiveKrpcGetPeersResponse(from, *query, response);
	}
	else if (methodName->Get() == KRPC_ANNOUNCE_PEER_METHOD_NAME)
	{
		OnReceiveKrpcAnnounceResponse(from, *query, response);
	}
	else
	{
		assert(0);
	}

	BitTorrentManager().DhtTaskManager().Dht().OnQueryResponseReceived(*query);
}// END OnReceiveKrpcResponse



// The appropriate response to a ping has a single key "id" containing the node ID of the responding node.
void OnReceiveKrpcPingResponse(const cSockAddr& from, const cKrpcQuery& sent, const cKrpcResponse& response)
{
	//Printf("OnReceiveKrpcPingResponse\n");
	
	if(sent.GetTask()==NULL)
	{
		assert(0);
		return;
	}

	sent.GetTask()->OnResponse(sent, response);
}// END OnReceiveKrpcPingResponse




// When a node receives a find_node query, it should respond with a key "nodes" and value of a string 
// containing the compact node info for the target node or the K (8) closest good nodes in its own routing table.
void OnReceiveKrpcFindNodeResponse(const net::cSockAddr& from, const cKrpcQuery& sent, const cKrpcResponse& response)
{
	//Printf("OnReceiveKrpcFindNodeResponse\n");

	if(!sent.GetTask())
	{
		assert(0);
		return;
	}

	sent.GetTask()->OnResponse(sent, response);
}// END OnReceiveKrpcFindNodeResponse




// If the queried node has peers for the infohash, they are returned in a key "values" as a list of strings. Each string containing "compact" format 
// peer information for a single peer. If the queried node has no peers for the infohash, a key "nodes" is returned containing the K nodes in the 
// queried nodes routing table closest to the infohash supplied in the query. In either case a "token" key is also included in the return value. The 
// token value is a required argument for a future announce_peer query. The token value should be a short binary string.
void OnReceiveKrpcGetPeersResponse(const net::cSockAddr& from, const cKrpcQuery& sent, const cKrpcResponse& response)
{
	//Printf("OnReceiveKrpcGetPeersResponse\n");

	BitTorrentManager().DhtTaskManager().Dht().OnGetPeersResponse();

	const cBencodedString* token = dynamic_cast<const cBencodedString*> (response.GetResponseValue("token"));
	if(!token)
	{
		// bad message, probably flag as bad node and remove them
		//assert(0);
		
		Printf("no token sent with get peers response\n");

		// TODO : as long as we are not going to announce to them then we could actually accept this

		// for now call through this so that its not outstanding
		sent.GetTask()->OnTaskResponseTimeout(sent);

		// TODO : send error?

		return;
	}

	if(!sent.GetTask())
	{
		assert(0);
		return;
	}

	sent.GetTask()->OnResponse(sent, response);
}// END OnReceiveKrpcGetPeersResponse



void OnReceiveKrpcAnnounceResponse(const net::cSockAddr& from, const cKrpcQuery& sent, const cKrpcResponse& response)
{
	if(!sent.GetTask())
	{
		assert(0);
		return;
	}

	sent.GetTask()->OnResponse(sent, response);
}// END OnReceiveKrpcAnnounceResponse